#include "/home/terra/TerraNG/terra/TerraNet.defs"

/*
** Definições para melhorar a leitura do codigo
*/
#define MAX_TEMP 600
#define TIPO_INUNDACAO 0
#define TIPO_PEDIDO 1
#define TIPO_RESPOSTA 2
#define TIPO_ROTEAMENTO 3
#define NO_RAIZ 11
#define NO_DESTINATARIO 41
#define NO_DESTINATARIO_ALTERNATIVO 23

/*
** Tipo mensagem com os campos especificos da aplicação
*/
pktype mensagem from radioMsg with
	var ushort destinatario;
	var ushort temperatura;
	var ushort versao;
	var ushort saltos;
	var ushort origem;
end

/*
** Variaveis globais da aplicação
*/
var ushort idLocal = getNodeId();
var ushort progenitorLocal = 0;
var ushort versaoLocal = 0;
var ushort tempLocal = 0;
var ushort voltLocal = 0;
var ubyte temperatura_idx = 0;
var ushort[4] temperaturas;
var ushort[16] tabela_roteamento;

loop i,3 do
	temperaturas[i] = 0;
end
loop i,15 do
	tabela_roteamento[i] = 0;
end

var ushort[4] vizinhosDiretos;
var ubyte vizinhoDireto_idx = 0;

par do
	/*
	** Bloco responsavel por verificar a temperatura a cada 10s;
	** Acende o LED amarelo como alerta quando a temperatura ultrapassa MAX_TEMP;
	** Guarda a temperatura num vetor de temperaturas, eliminando sempre a mais antiga.
	*/
	loop do
		par/and do
			emit REQ_TEMP();
			tempLocal = await TEMP;
			if tempLocal > MAX_TEMP then
				emit LED2(ON);
			else
				emit LED2(OFF);
			end
			temperaturas[temperatura_idx] = tempLocal;
			inc temperatura_idx;
			if temperatura_idx == 4 then
				temperatura_idx = 0;
			end
		with
			await 10s;
		end
	end
with
	/*
	** Bloco responsavel por iniciar inundações;
	** Exclusivo do nó 11 (raiz).
	*/
	if idLocal == 11 then
		var mensagem msgInundacao;
		msgInundacao.target = BROADCAST;
		msgInundacao.source = idLocal;
		msgInundacao.type = TIPO_INUNDACAO;
		msgInundacao.versao = 0;
		msgInundacao.saltos = 0;
		
		var mensagem msgPedido;
		msgPedido.source = idLocal;
		msgPedido.type = TIPO_PEDIDO;
		
		par do
			/*
			** Bloco responsavel por enviar uma inundação a cada 60s, acendendo LEDs especificos para fins de alerta que o evento está acontecendo;
			** Incrementa-se a versão contida na variavel msgInundacao antes de cada envio.
			*/
			loop do
				par/and do
					emit LED0(ON);
					emit LED1(ON);
					await 1s;
					
					inc versaoLocal;
					msgInundacao.versao = versaoLocal;
					qPut(msgInundacao);
					
					emit LED0(OFF);
					emit LED1(OFF);
				with
					await 60s;
				end
			end
		with
			/*
			** Bloco responsavel por enviar pedidos, acendendo LEDs especificos para fins de alerta que o evento está acontecendo;
			** Incrementa-se a versão contida na variavel msgInundacao antes de cada envio;
			** Se a voltagem for maior que 1000, envia-se um pedido de temperatura para o nó DESTINATARIO (42);
			** Caso a voltagem seja menor que 1000, envia-se para o DESTINATARIO_ALTERNATIVO (23).
			*/
			loop do
				par/and do
					emit REQ_VOLTS();
					voltLocal = await VOLTS;
					if voltLocal != 1000 then
						emit LED1(ON);
						emit LED2(ON);
						await 1s;
						
						inc versaoLocal;
						msgPedido.versao = versaoLocal;
						if voltLocal > 1000 then
							msgPedido.destinatario = NO_DESTINATARIO;
						else/if voltLocal < 1000 then
							msgPedido.destinatario = NO_DESTINATARIO_ALTERNATIVO;
						end
						
						var ushort index_roteamento = 0;
						if msgPedido.destinatario/10 == 1 then
							index_roteamento = msgPedido.destinatario - 11;
						else/if msgPedido.destinatario/10 == 2 then
							index_roteamento = msgPedido.destinatario - 17;
						else/if msgPedido.destinatario/10 == 3 then
							index_roteamento = msgPedido.destinatario - 23;
						else
							index_roteamento = msgPedido.destinatario - 29;
						end
						msgPedido.target = tabela_roteamento[index_roteamento];
						if msgPedido.target == 0 then
							msgPedido.target = BROADCAST;
						end
						qPut(msgPedido);
						
						emit LED1(OFF);
						emit LED2(OFF);
					end
				with
					await 4s;
				end
			end
		end
	end
with
	/*
	** Bloco responsavel por receber e tratar mensagens antes de enfileira-la para envio
	*/
	loop do
		var mensagem msgRecebida = await RECEIVE;
		/*
		** Reponsavel por tratar mensagens de inundação (type=0);
		** Caso a versão seja maior que a local, atualiza-se as informações locais e as da mensagem antes de passa-la adiante;
		*/
		if msgRecebida.type == TIPO_INUNDACAO then
			if msgRecebida.versao > versaoLocal then
				emit LED0(ON);
				
				await 1s;
				// Atualização da mensagem para passar adiante;
				versaoLocal = msgRecebida.versao;
				progenitorLocal = msgRecebida.source;
				msgRecebida.source = idLocal;
				inc msgRecebida.saltos;
				qPut(msgRecebida);
				
				// Atualização da mensagem para roteamento;
				msgRecebida.target = progenitorLocal;
				msgRecebida.origem = idLocal;
				msgRecebida.type = TIPO_ROTEAMENTO;
				qPut(msgRecebida);
				
				emit LED0(OFF);
			end
		else
			/*
			** Reponsavel por tratar mensagens de pedidos de temperatura (type=1);
			** Caso o nó seja o destinatario, calcula-se a media das temperaturas e envia uma mensagem de resposta a raiz, passando por todos os progenitores;
			** Caso contrario, passará a mensagem adiante.			
			*/
			if msgRecebida.type == TIPO_PEDIDO then
				if msgRecebida.destinatario == idLocal then
					emit LED0(ON); // Acende todos os LEDS indicando que o destinatario inicial foi alcançado
					emit LED1(ON);
					emit LED2(ON);
					await 1s;
					
					var mensagem msgResposta;
					msgResposta.source = idLocal;
					msgResposta.type = TIPO_RESPOSTA;
					msgResposta.destinatario = NO_RAIZ;
					msgResposta.temperatura = (temperaturas[0]+temperaturas[1]+temperaturas[2]+temperaturas[3])/4;
					msgResposta.target = progenitorLocal;
					msgResposta.versao = versaoLocal;
					qPut(msgResposta);
					
					emit LED0(OFF);
					emit LED1(OFF);
					emit LED2(OFF);
				else
					emit LED1(ON);
					await 2s;
					
					var ushort index_roteamento = 0;
					if msgRecebida.destinatario/10 == 1 then
						index_roteamento = msgRecebida.destinatario - 11;
					else/if msgRecebida.destinatario/10 == 2 then
						index_roteamento = msgRecebida.destinatario - 17;
					else/if msgRecebida.destinatario/10 == 3 then
						index_roteamento = msgRecebida.destinatario - 23;
					else
						index_roteamento = msgRecebida.destinatario - 29;
					end
					msgRecebida.target = tabela_roteamento[index_roteamento];
					msgRecebida.source = idLocal;
					qPut(msgRecebida);
					
					emit LED1(OFF);
				end
				
			/*
			** Reponsavel por tratar mensagens de resposta de temperatura (type=2);
			** Caso a resposta tenha atingido seu destino, ou seja, chegou ao nó raiz, acende-se todos os LEDs para fins de alerta;
			** Caso contrario, envia-se a mensagem para seu progenitor.
			*/
			else
				if msgRecebida.type == TIPO_RESPOSTA then
					if msgRecebida.destinatario == idLocal then
						emit LED0(ON); // Acende todos os LEDS indicando que o destinatario final foi alcançado
						emit LED1(ON);
						emit LED2(ON);
						await 6s;
						emit LED0(OFF);
						emit LED1(OFF);
						emit LED2(OFF);
					else
						emit LED2(ON);
						await 1s;
						
						msgRecebida.target = progenitorLocal;
						qPut(msgRecebida);
						
						emit LED2(OFF);
					end
				else
					/*
					** Reponsavel por guardar os sucessores diretos do nó (type=3);
					** Cada mensagem recebida, informando sobre sucessores, é enfileirada no vetor vizinhosDiretos, de forma a eliminar sempre o mais antigo.
					*/
					if msgRecebida.type == TIPO_ROTEAMENTO then
						emit LED1(ON);
						await 1s;
						
						var ushort index_roteamento = 0;
						if msgRecebida.origem/10 == 1 then
							index_roteamento = msgRecebida.origem - 11;
						else/if msgRecebida.origem/10 == 2 then
							index_roteamento = msgRecebida.origem - 17;
						else/if msgRecebida.origem/10 == 3 then
							index_roteamento = msgRecebida.origem - 23;
						else
							index_roteamento = msgRecebida.origem - 29;
						end
						tabela_roteamento[index_roteamento] = msgRecebida.source;
						if idLocal != NO_RAIZ then
							msgRecebida.source = idLocal;
							msgRecebida.target = progenitorLocal;
							qPut(msgRecebida);
						end
						emit LED1(OFF);
					end
				end
			end
		end
	end
with
	/*
	** Bloco responsavel por enviar mensagens da fila.
	*/
	loop do
		await Q_READY();
		loop do
			if qSize() == 0 then
				break;
			end
			var mensagem enviar;
			qGet(enviar);
			emit SEND(enviar);
			await SEND_DONE;
			await 1s;
		end
	end
end
